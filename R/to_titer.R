#' Process assay test result to titer
#'
#' @param df - a standardized data.frame generated by`standardize_data()`
#' @param model - either the name of a built-in model to fit standard curve or a named list of 2 functions for "mod" and "quantify_ci"
#' @param positive_threshold - if not NULL, processed_data will have the serostatus labeled
#' @param ci - confidence interval for the titer estimates
#' @param negative_control - if TRUE, output tibble will include the result for negative controls
#' @importFrom magrittr %>%
#' @import dplyr purrr
#'
#' @return a data.frame with 8 columns
#'   \item{plate_id}{id of the plate}
#'   \item{data}{list of `data.frame`s containing the results from each plate}
#'   \item{antitoxin_df}{list of `data.frame`s containing the results for antitoxins from each plate}
#'   \item{standard_curve_func}{list of functions mapping from OD to titer for each plate}
#'   \item{std_crv_midpoint}{midpoint of the standard curve, for qualitative analysis}
#'   \item{processed_data}{list of `tibble`s containing samples with titer estimates (lower, median, upper)}
#'   \item{negative_control}{list of `tibble`s containing negative control check results (if `negative_control=TRUE`)}
#' @export
to_titer <- function(df, model="4PL", positive_threshold=NULL, ci = .95,
                     negative_control=TRUE){
  # Expected format for df
  # have columns: sample_id (which can be id of sample or label as antitoxin), result, dilution_factors, negative control

  mod <- if (is.character(model) && model == "4PL") {
    nls4PL
  } else if (is.list(model) && is.function(model[["mod"]])) {
    model[["mod"]]
  }

  quantify_ci_func <- if (is.character(model) && model == "4PL") {
    simulate_nls_ci
  } else if (is.list(model) && is.function(model[["quantify_ci"]])) {
    model[["quantify_ci"]]
  }

  out <- df %>%
    group_by(plate_id) %>%
    nest() %>%
    mutate(
      # For each data from each plate, do the following
      # 1: retrieve the anti-toxins data from all plates
      antitoxin_df = map(data, get_antitoxins),
      # 2: generate the standard curve with CI in the form of a dataframe
      standard_curve_df = map(antitoxin_df, \(df, mod) standard_curve_data(df, mod, quantify_ci=quantify_ci_func, level=ci), mod),
      # 3: convert the standard curve dataframe into a standard curve function
      standard_curve_func = map(standard_curve_df, data2function),
      # 4: get the midpoint of the result for qualitative analysis when OD is too high
      std_crv_midpoint = map_dbl(antitoxin_df, \(df) median(df$result, na.rm = TRUE) ),
      # 5: convert the OD of the samples into log-concentrations
      processed_data = pmap(list(data, standard_curve_func, std_crv_midpoint), \(dat, func, midpoint) {
        dat %>%
          filter(sample_id != "antitoxin") %>%
          process_samples(func, midpoint=midpoint, positive_threshold = positive_threshold)
      })
    )

  if(negative_control){
    assert_that(is.numeric(positive_threshold),
                msg = "A threshold value must be provided when `negative_control=TRUE`")

    out <- out %>%
      mutate(
        negative_control = map(data, get_negative_controls),
        negative_control = pmap(list(negative_control, standard_curve_func, std_crv_midpoint), \(dat, func, midpoint) {
          process_samples(dat, func, midpoint = midpoint, positive_threshold = positive_threshold)
        })
      )
  }

  out
}

#' Preprocess data
#'
#' @param df - data.frame with columns for plate id, sample id, result, dilution factor, and (optionally) negative controls
#' @param plate_id_col - name of the column storing plates id
#' @param id_col - name of the column storing sample id
#' @param result_col - name of the column storing result
#' @param dilution_fct_col - name of the column storing dilution factors
#' @param antitoxin_label - how antitoxin is label in the sample id column
#' @param negative_col - regex for columns for negative controls, assumed to be a label followed by the dilution factor (e.g. NEGATIVE_50, NEGATIVE_100)
#'
#' @importFrom magrittr %>%
#' @importFrom janitor clean_names
#'
#' @import dplyr
#'
#' @return a standardized data.frame that can be passed to `to_titer()`
#' @export
standardize_data <- function(df,
                             plate_id_col = "PLATE_ID",
                             id_col = "SAMPLE_ID",
                             result_col = "RESULT",
                             dilution_fct_col = "DILUTION_FACTORS",
                             antitoxin_label = "Anti_toxin",
                             negative_col = "^NEGATIVE_*"){

  neg_control_cols <- grep(negative_col, colnames(df), value = TRUE)
  if (length(neg_control_cols) == 0){
    message("Columns for negative controls not detected")
  }else{
    colnames(df) <- gsub(negative_col, "negative_", colnames(df))
  }

  df <- df %>%
    rename(
      plate_id := plate_id_col,
      sample_id := id_col,
      result := result_col,
      dilution_factors := dilution_fct_col
    ) %>%
    clean_names() %>%
    mutate(
      sample_id = if_else(sample_id == antitoxin_label, "antitoxin", sample_id)
    )


  df
}

# ======= Helper functions =======
# Helper function to do 2 things
# - get antitoxins data
# - compute concentration from reference concentration and dilution factor
get_antitoxins <- function(plate, ref_conc = 10) {
  # resolve no visible binding NOTE
  sample_id <- dilution_factors <- NULL

  plate %>%
    filter(sample_id == "antitoxin") %>%
    mutate(concentration = ref_conc / dilution_factors)
}

# Function to generate the standard curve and its confidence interval
standard_curve_data <- function(df, model, quantify_ci=simulate_nls_ci,
                                le = 512, level = .95, nb = 9999) {

  log_concentration <- log10(df$concentration)
  logc <- seq(min(log_concentration), max(log_concentration), le = le)
  alpha <- (1 - level) / 2
  df %>%
    model() %>%
    quantify_ci(list(concentration = 10^logc), nb=nb, alpha=alpha) %>%
    (\(.x) bind_cols(logc = logc, .x))()
}

# Function to turn the standard curve data.frame to a function that coverts OD to LC
data2function <- function(df) {
  with(df, {
    approxfun2 <- function(...) approxfun(y = logc, ...)
    pred_lwr <- approxfun2(upper)
    pred_mdi <- approxfun2(median)
    pred_upp <- approxfun2(lower)
    function(x) c(lower = pred_lwr(x), median = pred_mdi(x), upper = pred_upp(x))
  })
}

# Function to convert samples' OD to LC
process_samples <- function(plate, std_crv, midpoint=2, positive_threshold = NULL) {
  out <- plate %>%
    bind_cols(map_dfr(.$result, std_crv))

  if(is.numeric(positive_threshold)){
    out <- out %>% mutate(
      positive = if_else(
        # check if upper bound for titer is available
        !is.na(upper),
        upper >= positive_threshold, # positive if above threshold
        # if upper is NA, then OD (or result) is either too high or too low
        # label positive when result is higher than midpoint
        result > midpoint
      )
    )
  }
}

# === Functions for 4PL model ========
# Helper function to look at the data and generate a good initial guess for the parameters
good_guess4PL <- function(x, y, eps = .3) {
  nb_rep <- unique(table(x))
  the_order <- order(x)
  x <- x[the_order]
  y <- y[the_order]
  a <- min(y)
  d <- max(y)
  c <- approx(y, x, (d - a) / 2, ties = "ordered")$y
  list(a = a, c = c, d = d,
       b = (
         approx(x, y, c + eps, ties = "ordered")$y -
           approx(x, y, c - eps, ties = "ordered")$y
       ) / (2 * eps))
}


# function to fit data to a 4PL model
nls4PL <- function(df) {
  nls(result ~ d + (a - d) / (1 + 10^((log10(concentration) - c) * b)),
      data = df,
      start = with(df, good_guess4PL(log10(concentration), result)))
}

# helper function to generate data to quantify confidence interval (using bootstrapping)
# general flow is:
# - sample different values for parameters (number of samples = nb)
# - use model to compute OD for the new set of parameter values
#' @importFrom mvtnorm rmvnorm
simulate_nls_ci <- function(object, newdata, nb = 9999, alpha = .025) {
  rowsplit <- function(df) split(df, 1:nrow(df))

  nb |>
    rmvnorm(mean = coef(object), sigma = vcov(object)) |>
    as.data.frame() |>
    rowsplit() |>
    map(as.list) |>
    map(~ c(.x, newdata)) |>
    map_dfc(eval, expr = parse(text = as.character(formula(object))[3])) %>%
    apply(1, quantile, c(alpha, .5, 1 - alpha))  %>%
    t() %>%  as.data.frame() %>%
    setNames(c("lower", "median", "upper"))
}

# ===== Quality Control functions ========
# only use dilution factor where negative sample is indeed negative
get_negative_controls <- function(plate, std_crv){
  plate %>%
    select(starts_with("negative")) %>%
    unique() %>%
    tidyr::pivot_longer(everything(), names_to = "dilution", values_to = "result") %>%
    mutate(across(dilution, ~ stringr::str_remove(.x, "negative_") %>%  as.integer()))
}

# ======== Plot functions ==========
#' Visualize standard curves for each plate
#'
#' @param x - output of `to_titer()`
#' @param facet - whether to faceted by plates or plot all standard curves on a single plot
#' @param xlab - label of the x axis
#' @param ylab - label of the y axis
#' @param datapoint_size - size of the data point (only applicable when `facet=TRUE`)
#'
#' @importFrom magrittr %>%
#' @import ggplot2 dplyr
#'
#' @export
plot_standard_curve <- function(x, facet=TRUE,
                                xlab = "log10(concentration)",
                                ylab = "Optical density",
                                datapoint_size = 2){
  scdf <- x %>% select(plate_id, standard_curve_df) %>% unnest(standard_curve_df) %>% ungroup()
  data <- x %>% select(plate_id, antitoxin_df) %>% unnest(antitoxin_df) %>% ungroup()

  if (is.null(ylim)) ylim <- c(0, max(scdf$upper, data$result))

  plot <- ggplot()  +
    geom_line(
      aes(
        x = logc, y = median, group = if (!facet) plate_id else NULL
      ),
      color = "#fc0328", lwd = 0.5, data = scdf, show.legend = FALSE
    ) +
    labs(
      x = xlab,
      y = ylab
    )

  if (facet){
    plot <- plot +
      geom_ribbon(
        aes(
          x = logc, y = median, ymin = lower, ymax = upper
        ),
        fill = adjustcolor("#fc0328", alpha.f = 0.2), data = scdf
      ) +
      geom_point(
        aes(
          x = log10(concentration),
          y = result
        ),
        shape = 3, size = datapoint_size,
        color = "blue", alpha = 0.8,
        data = data
      ) +
      facet_wrap(~plate_id, drop = TRUE)
  }
  plot
}

#' Visualize positive threshold at different dilution factors
#'
#' @param dilution_factors dilution factors to be visualized
#' @param positive_threshold titer threshold for sample to be considered positive
#' @param shift_text adjust how much the text is shifted along the x-axis (relative to the threshold line)
#'
#' @importFrom magrittr %>%
#' @import ggplot2 dplyr purrr
#'
#' @export
add_thresholds <- function(dilution_factors, positive_threshold = 0.1,
                           shift_text = 0.15) {
  list(
    geom_vline(aes(xintercept = log10(
      positive_threshold / c(1, dilution_factors)
    )),
    color = "forestgreen"),
    geom_text(
      aes(x = x, y = 4, label = label),
      data = data.frame(
        x = log10(positive_threshold / c(1, dilution_factors)) + shift_text,
        label = paste0("1:", c(1, dilution_factors))
      ),
      color = "forestgreen"
    )
  )
}


#' Quality control plot
#'
#' Visualize for each sample, whether titer estimates can be computed at the tested dilutions.
#'
#' Each sample is represented by a `n_estimates x n_dilutions` grid where cell color indicate
#' estimate availability (green = estimate available, orange = result too low, red = result too high)
#'
#' These sample grids are arranged in columns where each column represent samples from a plate
#'
#' The figure below demonstrates the interpretation of the plot.
#' \figure{interpret_titer_qc.png}{options: width="70\%"}
#'
#' @param x - output of `to_titer()`
#' @param n_plates - maximum number of plates to plot
#' @param n_samples - maximum number of samples per plate to plot
#' @param n_dilutions - number of dilutions used for testing
#'
#' @importFrom magrittr %>%
#' @import ggplot2 dplyr purrr
#'
#' @export
plot_titer_qc <- function(x, n_plates=18, n_samples=22, n_dilutions = 3){
  # function to add missing values if there are less than 22 samples in a plate:
  n_estimates <- 3 # number of estimates per dilution (point + confidence interval)
  n_plates <- if(is.numeric(n_plates)) n_plates else nrow(x)

  template <- matrix(rep(NA, n_samples * n_dilutions * n_estimates), nrow = n_estimates)
  format_mat <- function(x) {
    template[, 1:min(n_samples*n_dilutions, ncol(x))] <- x[,1:min(n_samples*n_dilutions, ncol(x))]
    template
  }

  # get standard curve midpoint to determine whether OD is too high or too low when titer is NA
  midpoint <- median(x$std_crv_midpoint)

  # the function that draws the heatmap for 1 plate
  abline2 <- function(...) abline(..., col = "white")
  plot_heatmap <- function(x) {
    midpoint <- mean(range(x$result, na.rm = TRUE))

    x %>%
      mutate(across(c(lower, median, upper),
                    ~ as.numeric(is.na(.x)) * ((result > midpoint) + 1))) %>%
      select(lower, median, upper) %>%
      as.matrix() %>%
      t() %>%
      format_mat() %>%
      (\(.x) .x[, ncol(.x):1])()  %>%
      (\(.x) image(1:n_estimates, 1:(n_samples * n_dilutions), .x,
                   axes = FALSE, ann = FALSE, col = c(3, 7, 2), zlim = c(1,n_estimates)-1))()

    abline2(v = 1:(n_estimates-1) + .5)
    abline2(h = seq(n_dilutions, n_dilutions * n_samples, n_dilutions) + .5)
  }

  opar <- par(mfrow = c(1, n_plates), mar = c(0,0.25,0,0.25))
  walk(head(x$processed_data, n=n_plates), plot_heatmap)

  par(opar)
}
